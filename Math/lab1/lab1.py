# A - матрица коэффициентов уравнений
# B - вектор свободных членов
# maxEl - индекс максимального элемента
# maxRow - индекс строки с максимальным элементом

def gauss(A, B):  # Функция gauss принимает матрицу коэффициентов A и вектор свободных членов B
    n = len(A)  # определение размера матрицы
    if any(len(row) != n for row in A) or len(B) != n:  # проверка, что матрица A и вектор B имеют одинаковую длину
        return "Error!"  # возврат сообщения "Error!" в случае несоответствия размеров матрицы и вектора

    for i in range(n):  # начало цикла для каждой строки i матрицы A
        # поиск максимального элемента в текущем столбце
        maxEl = abs(A[i][i])  # максимальный элемент - начальное значение диагонального элемента
        maxRow = i  # сохранение индекса строки с максимальным элементом
        for k in range(i + 1, n):  # цикл для поиска максимального элемента ниже текущего элемента
            if abs(A[k][i]) > maxEl:  # если модуль элемента больше текущего максимального
                maxEl = abs(A[k][i])  # обновление максимального значения
                maxRow = k  # обновление индекса строки с максимальным элементом

        # обмен строками для упорядочивания максимального элемента сверху
        A[maxRow], A[i] = A[i], A[maxRow]  # обмен строк матрицы
        B[maxRow], B[i] = B[i], B[maxRow]  # обмен строк вектора свободных членов

        # проверка на вырожденность или несовместность системы
        if abs(A[i][i]) < 1e-9:
            if abs(B[i]) < 1e-9:  # если диагональный элемент и свободный член близки к нулю
                return "Система имеет множество решений"
            return "Система несовместна"

        # прямой ход для обнуления элементов ниже текущей диагонали
        for k in range(i + 1, n):
            c = -A[k][i] / A[i][i]  # вычисление коэффициента для обнуления ниже диагонали
            for j in range(i, n):
                if i == j:  # если индексы совпадают, следует обнулить элемент
                    A[k][j] = 0
                else:
                    A[k][j] += c * A[i][j]  # обновление элементов для текущей строки
            B[k] += c * B[i]  # обновление элементов вектора свободных членов

    # обратный ход для нахождения решения
    x = [0 for _ in range(n)]  # инициализация списка для решения
    for i in range(n - 1, -1, -1):  # обратный цикл для решения
        x[i] = B[i] / A[i][i]  # нахождение значения переменной
        for k in range(i - 1, -1, -1):
            B[k] -= A[k][i] * x[i]  # обновление вектора свободных членов

    return x  # возврат списка решений


# A = [[1, 2, 3], #вырожденная матрица
#     [4, 5, 6],
#     [7, 8, 9]]

# A = [[1, 2, 3], #матрица с множеством решений
#     [2, 4, 6],
#     [4, 5, 7]]

A = [[0, 2, 3],  # матрица коэффициентов системы линейных уравнений
     [4, 5, 6],
     [7, 0, 9]]

# B = [1, 2, 5] #вектор свободных членов системы множетсво решений
B = [1, 2, 3]  # вектор свободных членов системы

print(gauss(A, B))  # вызов функции gauss и вывод решения
