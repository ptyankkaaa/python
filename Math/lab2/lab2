# решение неленейных уравнений методами биекции простых итераций и ньютона
ep = 1e-5  # точность решения
a, b = 0, 2  # интервал для метода бисекции
x0 = 0.25  # начальное приближение для метода Ньютона и простых итераций
max_iter = 100  # максимальное количество итераций


def f(x):  # функция
    return x ** 2 - 2
# разбивает интервал пополам и ищет в какой половине находится корень -> сужаем отрезок и ищем в той половине в которой ф-ия меняет знак.
# и так до тех пор пока отрезок не станет меньше точности
def bisection(f, ep, a, b):  # метод половинного деления (дихотомия)
    while (b - a) / 2 > ep: # пока разница между концами интервала деленная на 2 больше точности
        mid = (a + b) / 2 # находим середину интеварала
        if f(mid) == 0: # если зн. ф-ии в середине интервала == 0, то возвращаем корень
            return mid
        elif f(a) * f(mid) < 0: #если произведение значений функции в точках a и mid меньше 0, то корень находится в левой половине интервала, сдвигаем b к mid
            b = mid
        else: # иначе корень находится в правой половине -> сдвигаем к а
            a = mid
    return (a + b) / 2 # после возвращаем середину выбранного интервала как приближенное значение корня


def f1(x):
    return (2 + x ** 2) / (2 * x)  # изначальное преобразование к виду x = g(x)
# x + f(x) = x^2 - 2 + x
# x = x^2 - 2 + x
# x = x^2 + x - 2
# x/(2*x) = (x^2 + x - 2)/(2x)
# 1/2 = x/2 + f(x)/2x
# x = (2 + f(x))/(2*x)
# x = (2 + x^2)/(2 * x)

# последовательно вычисляются значения x1, x2, ... , xn по формуле x(n + 1) = g(xn)
def simple_iter(f1, x0, ep, max_iter):  # метод простых итераций
    x_prev = x0  # начальное приближение для х
    for cnt in range(max_iter):
        x_next = f1(x_prev) #вычисление след. значения
        if abs(x_next - x_prev) < ep: # проверка на достижение точности
            return x_next, cnt  # найденный корень и количество итераций
        x_prev = x_next
    return x_next, max_iter  # последнее приближение и max_iter, если точность не достигнута


def df(x):  # производная для ньютона
    return 2 * x

# использует формулу x(n + 1) = x(n) - f(x(n))/f'(x(n))
# x(n + 1) считается приблеженным значением корня
def newton(f, df, x0, ep):  # метод ньютона
    x = x0
    while True:
        x_next = x - f(x) / df(x) # расчет след. приближения корня
        if abs(x_next - x) < ep: # проверка на достижение точности
            return x_next # возвращение корня
        x = x_next # обновляем для след. итерации


root, cnt = simple_iter(f1, x0, ep, max_iter)
print(f"метод простых итераций: {root}, за {cnt} итераций")
root = newton(f, df, x0, ep)
print(f"методом Ньютона: {root}")
root = bisection(f, ep, a, b)
print(f"метод бисекции: {root}")